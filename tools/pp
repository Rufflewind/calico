#!/usr/bin/env python
import os, re, subprocess, sys

# note for future reference: Q. why does using #include as a templating
# mechanism suck?  A. it's non-composable: you can't sensibly include other
# templates from within templates, because the parameter macros will collide

def load_file(fn):
    with open(fn, "rt") as f:
        return f.read()

def escape_newlines(s):
    return s.replace("\n", " \\\n")

def replace_ident(s, old, new):
    return re.sub(r"\b{0}\b".format(re.escape(old)), lambda _: new, s)

def process_directives__replacement(m):
    body, = m.groups()
    return eval(body)

def process_directives(s):
    return re.sub(r"(?s)/\*@(.*?)\*/", process_directives__replacement, s)

def get_global_idents(code):
    with open(os.devnull, "w+b") as fdevnull:
        p = subprocess.Popen(["clang", "-cc1", "-ast-dump"],
                             stdout=subprocess.PIPE,
                             stdin=subprocess.PIPE,
                             stderr=fdevnull)
    out, _ = p.communicate(code.encode("utf-8"))

    identifiers = set()
    for line in out.decode("utf-8").split("\n"):
        if re.match(r".-\w*Decl|\| .-EnumConstantDecl", line):
            m = re.match(r".*?\w+ \S+ <.*?> (?:<.*?>|\S+) ([^']*)", line)
            if not m:
                continue
            x = m.group(1).split()
            if x[0] == "implicit":
                continue
            if x[0] in ["used", "referenced"]:
                x = x[1:]
            if x[0] in ["invalid"]:
                x = x[1:]
            if x[0] in ["struct"]:
                x = x[1:-1] # strip off "definition" too
            if not x:
                continue
            identifier, = x
            identifiers.add(identifier)
    return sorted(identifiers)

def prepend_prefix(s,
                   prefix_macro="Prefix",
                   public_pattern="",
                   exclude_pattern="",
                   private_subprefix="priv"):
    idents = get_global_idents(s)
    for ident in idents:
        if re.match("({0})$".format(exclude_pattern), ident):
            continue
        subprefix = private_subprefix
        if re.match("({0})$".format(public_pattern), ident):
            subprefix = ""
        s = replace_ident(
            s,
            ident,
            "cal_cat({0}, {1}_{2})".format(prefix_macro, subprefix, ident),
        )
    return s

def make_template(fn,
                  prefix_macro="Prefix",
                  public_pattern="",
                  exclude_pattern="",
                  private_subprefix="priv",
                  params=[]):
    s = []
    params = ["Prefix"] + list(params)
    s.append('#include "macros.h"\n')
    for param in params:
        param = param.split("=", 1)
        if len(param) == 1:
            param, = param
            default = None
        else:
            param, default = param
        s.append("#ifndef {0}\n".format(param))
        if default is None:
            s.append("#error Macro must be defined before "
                     "including this header: {0}\n".format(param))
        else:
            s.append("#define {0} {1}\n".format(param, default))
        s.append("#endif\n")
    idents = get_global_idents(load_file(fn))
    for ident in idents:
        if re.match("({0})$".format(exclude_pattern), ident):
            continue
        subprefix = private_subprefix
        if re.match("({0})$".format(public_pattern), ident):
            subprefix = ""
        s.append("#define {0} {1}\n".format(
            ident,
            "cal_cat({0}, {1}_{2})".format(prefix_macro, subprefix, ident),
        ))
    s.append('#include "{0}"\n'.format(fn))
    for ident in idents:
        if re.match("({0})$".format(exclude_pattern), ident):
            continue
        s.append("#undef {0}\n".format(ident))
    for param in params:
        s.append("#undef {0}\n".format(param.split("=", 1)[0]))
    return "".join(s).rstrip()

def read_attributes(fn):
    attributes = {}
    with open(fn, "rt") as f:
        for line in f:
            m = re.match("\s*/\*@(.*?)=(.*?)\*/", line)
            if not m:
                continue
            k, v = m.groups()
            attributes[k] = v
    return attributes

def preproc(fn):
    fn = os.path.abspath(fn)
    os.chdir(os.path.dirname(fn))
    sys.stdout.write(process_directives(load_file(fn)))

if len(sys.argv) > 1:
    eval(sys.argv[1] + "(" + ", ".join(repr(x) for x in sys.argv[2:]) + ")")
