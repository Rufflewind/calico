#!/usr/bin/env python
import os, re, subprocess, sys

# note for future reference: Q. why does using #include as a templating
# mechanism suck?  A. it's non-composable: you can't sensibly include other
# templates from within templates, because the parameter macros will collide

#@snip/WorkDir[
#@requires: mod:os
class WorkDir(object):
    '''A context manager for changing to a different working directory.  The
    original working directory is restored upon exiting the context.'''

    def __init__(self, path):
        '''Initialize a context for changing the working directory.'''
        self.path = path

    def __enter__(self):
        '''Change the working directory and return the path to the previous
        working directory.'''
        self.prevdir = os.getcwd()
        os.chdir(self.path)
        return self.prevdir

    def __exit__(self, type, value, traceback):
        '''Restore the the temporary directory.'''
        os.chdir(self.prevdir)
#@]

def load_file(fn):
    with open(fn, "rt") as f:
        return f.read()

def escape_newlines(s):
    return s.replace("\n", " \\\n")

def replace_ident(s, old, new):
    return re.sub(r"\b{0}\b".format(re.escape(old)), lambda _: new, s)

def get_global_idents(code):
    with open(os.devnull, "w+b") as fdevnull:
        p = subprocess.Popen(["clang", "-cc1", "-ast-dump"],
                             stdout=subprocess.PIPE,
                             stdin=subprocess.PIPE,
                             stderr=fdevnull)
    out, _ = p.communicate(code.encode("utf-8"))

    identifiers = set()
    for line in out.decode("utf-8").split("\n"):
        if re.match(r".-\w*Decl|\| .-EnumConstantDecl", line):
            m = re.match(r".*?\w+ \S+ <.*?> (?:<.*?>|\S+) ([^']*)", line)
            if not m:
                continue
            x = m.group(1).split()
            if x[0] == "implicit":
                continue
            if x[0] in ["used", "referenced"]:
                x = x[1:]
            if x[0] in ["invalid"]:
                x = x[1:]
            if x[0] in ["struct"]:
                x = x[1:-1] # strip off "definition" too
            if not x:
                continue
            identifier, = x
            identifiers.add(identifier)
    return sorted(identifiers)

def prepend_prefix(s,
                   prefix_macro="Prefix",
                   public_pattern="",
                   exclude_pattern="",
                   private_subprefix="priv"):
    idents = get_global_idents(s)
    for ident in idents:
        if re.match("({0})$".format(exclude_pattern), ident):
            continue
        subprefix = private_subprefix
        if re.match("({0})$".format(public_pattern), ident):
            subprefix = ""
        s = replace_ident(
            s,
            ident,
            "cal_cat({0}, {1}_{2})".format(prefix_macro, subprefix, ident),
        )
    return s

def make_public():
    return ""

def make_template(fn,
                  prefix_macro="Prefix",
                  public_pattern="",
                  exclude_pattern="",
                  private_subprefix="priv",
                  params=[]):
    s = []
    params = ["Prefix"] + list(params)
    s.append('#include "macros.h"\n')
    for param in params:
        param = param.split("=", 1)
        if len(param) == 1:
            param, = param
            default = None
        else:
            param, default = param
        s.append("#ifndef {0}\n".format(param))
        if default is None:
            s.append("#error Macro must be defined before "
                     "including this header: {0}\n".format(param))
        else:
            s.append("#define {0} {1}\n".format(param, default))
        s.append("#endif\n")
    idents = get_global_idents(load_file(fn))
    for ident in idents:
        if re.match("({0})$".format(exclude_pattern), ident):
            continue
        subprefix = private_subprefix
        if re.match("({0})$".format(public_pattern), ident):
            subprefix = ""
        s.append("#define {0} {1}\n".format(
            ident,
            "cal_cat({0}, {1}_{2})".format(prefix_macro, subprefix, ident),
        ))
    s.append('#include "{0}"\n'.format(fn))
    for ident in idents:
        if re.match("({0})$".format(exclude_pattern), ident):
            continue
        s.append("#undef {0}\n".format(ident))
    for param in params:
        s.append("#undef {0}\n".format(param.split("=", 1)[0]))
    return "".join(s).rstrip()

def read_attributes(fn):
    attributes = {}
    with open(fn, "rt") as f:
        for line in f:
            m = re.match("\s*/\*@(.*?)=(.*?)\*/", line)
            if not m:
                continue
            k, v = m.groups()
            attributes[k] = v
    return attributes

class Preprocessor(object):

    def __init__(self, filename):
        self.filename = os.path.abspath(filename)

    def preprocess(self):
        s = load_file(self.filename)
        with WorkDir(os.path.dirname(self.filename)):
            sys.stdout.write(self._process_directives(s))

    def _process_directives_replacement(self, _m):
        _body, = _m.groups()
        if _body.lstrip().startswith("#"):
            return ""
        return eval(_body)

    def _process_directives(self, s):
        return re.sub(r"(?s)/\*@(.*?)\*/",
                      self._process_directives_replacement,
                      s)

def preproc(fn):
    Preprocessor(fn).preprocess()

if len(sys.argv) > 1:
    eval(sys.argv[1] + "(" + ", ".join(repr(x) for x in sys.argv[2:]) + ")")
